# Processing to create the Turtle rendering of the events for the sentences in a narrative
# The sentences are defined by their sentence dictionaries, which have the form:
#    'text': 'narrative_text',
#    'LOCS': ['location1', ...], 'TIMES': ['dates_or_times1', ...], 'EVENTS': ['event1', ...],
#    'subjects': [{'subject_text': 'subject_text', 'subject_type': 'type_such_as_SINGNOUN'},
#                 {'subject_text': 'Narrator', 'subject_type': 'example_FEMALESINGPERSON'}],
#    'verbs': [{'verb_text': 'verb_text', 'verb_lemma': 'verb_lemma', 'tense': 'tense_such_as_Past',
#               'preps': [{'prep_text': 'preposition_text',
#                          'prep_details': [{'detail_text': 'preposition_object', 'detail_type': 'type_eg_SINGGPE'}]}],
#                          # Preposition object may also have a preposition - for ex, 'with the aid of the police'
#                          # If so, following the 'detail_type' entry would be another 'preps' element
#                          'objects': [{'object_text': 'verb_object_text', 'object_type': 'type_eg_SINGNOUN'}]}]}]}]}]}

import copy
import logging
import uuid

from coreference_resolution import check_nouns
from create_event_time_loc import names_to_geo_dict, get_location_uri_and_ttl, \
    get_sentence_location, get_sentence_time
from database import query_database
from idiom_processing import get_verb_processing
from nlp import get_sentence_sentiment
from query_ontology_and_sources import get_noun_ttl, get_event_state_ttl
from utilities import domain_database, empty_string, objects_string, preps_string, \
    subjects_string, verbs_string, add_unique_to_array

dependency_refs = ('acomp', objects_string, 'xcomp')

query_domain = 'prefix : <urn:ontoinsights:dna:> SELECT ?uri ?type ?prob WHERE ' \
               '{ ?uri a ?type . ' \
               '{ { ?uri rdfs:label ?label . FILTER(?label = "keyword") . BIND(100 as ?prob) } UNION ' \
               '{ ?uri :noun_synonym ?nsyn . FILTER(?nsyn = "keyword") . BIND(100 as ?prob) } UNION ' \
               '{ ?uri rdfs:label ?label . FILTER(CONTAINS(?label, "keyword")) . BIND(90 as ?prob) } UNION ' \
               '{ ?class :noun_synonym ?nsyn . FILTER(CONTAINS(?nsyn, "keyword")) . BIND(90 as ?prob) } UNION ' \
               '{ ?uri rdfs:label ?label . FILTER(CONTAINS(lcase(?label), "keyword")) . BIND(85 as ?prob) } ' \
               'UNION { ?uri rdfs:label ?label . FILTER(CONTAINS("keyword", ?label)) . BIND(80 as ?prob) } } } ' \
               'ORDER BY DESC(?prob)'


# TODO: of someone (possession), of something (part), of related to measurement (2 lbs of potatoes)
# TODO: https://www.oxfordlearnersdictionaries.com/us/definition/english/of
# TODO: near loc, on loc, https://www.oxfordlearnersdictionaries.com/us/definition/english/over_1
# TODO: without x
# Date processing is handled differently/separately
prep_to_predicate_for_locs = {'about': ':has_topic',
                              'at': ':has_location',
                              'from': ':has_origin',
                              'to': ':has_destination',
                              'in': ':has_location'}


def check_domain_specific_match(noun: str, noun_type: str) -> (str, str):
    """
    Checks if the concept/Person/Location/... is already defined in the domain-specific ontology modules.

    :param noun: String holding the text to be matched
    :param noun_type: String holding the noun type (PERSON/GPE/LOC/...) from spacy's NER
    :return A tuple consisting of the matched URI and its type (if a match is found) or two empty strings
    """
    if noun_type.endswith('PERSON') or noun_type.endswith('GPE') or noun_type.endswith('LOC') \
            or noun_type.endswith('ORG') or noun_type.endswith('NORP') or noun_type.endswith('EVENT'):
        domain_details = query_database('select', query_domain.replace('keyword', noun), domain_database)
        if domain_details:
            return domain_details[0]['uri']['value'], domain_details[0]['type']['value']
    return empty_string, empty_string


def create_event_turtle(narr_gender: str, sentence_dicts: list) -> list:
    """
    Using the sentence dictionaries generated by the nlp_graph functions, create the Turtle
    rendering of the events.

    :param narr_gender: Either an empty string or one of the values, AGENDER, BIGENDER, FEMALE or MALE -
                        indicating the gender of the narrator
    :param sentence_dicts: An array of sentence dictionaries for a narrative
    :return A list of the Turtle statements
    """
    logging.info(f'Creating event Turtle')
    last_date = empty_string  # Track the last mentioned date/time/event
    # List of dates/times/specific events in the sentences
    processed_dates = []      # Track all dates/times/events mentioned in the Turtle to only define once
    last_loc = empty_string   # Track the last mentioned location
    # Track all locations mentioned in the Turtle to only define once
    processed_locs = dict()   # Keys are location strings and the values are their URIs
    last_nouns = []           # List of tuples (noun text and type) from previous sentence - Used for coref resolution
    graph_ttl_list = ['@prefix : <urn:ontoinsights:dna:> .', '@prefix dna: <urn:ontoinsights:dna:> .',
                      '@prefix geo: <urn:ontoinsights:geonames:> .',
                      '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .']
    for sent_dict in sentence_dicts:
        sentence_text = sent_dict['text']
        sentence_offset = sent_dict['offset']
        if not sentence_text[0].isalnum():
            # Parse can return a verb_text of punctuation or new line; Ignore this
            continue
        if sentence_text == 'New line':
            last_nouns = []         # Reset list of last_nouns (coref only selects from current paragraph)
            continue
        sent_keys = sent_dict.keys()
        new_loc = empty_string
        if 'LOCS' in sent_keys:
            new_loc = get_sentence_location(sent_dict, last_loc)
            if not last_loc:
                last_loc = new_loc
        if 'TIMES' in sent_keys or 'EVENTS' in sent_keys:
            # Format of last_date: ('before'|'after'|'') (PointInTime date)
            last_date, date_ttl = get_sentence_time(sent_dict, last_date, processed_dates)
            if date_ttl:
                graph_ttl_list.extend(date_ttl)
        subjects = []
        if subjects_string in sent_keys:
            # Get the subject nouns in the sent_dictionary and if a pronoun, attempt to resolve co-references
            subjects = check_nouns(narr_gender, sent_dict, subjects_string, last_nouns)

        sentence_ttl_list = []
        objects = []
        for verb in sent_dict[verbs_string]:
            event_uri, new_ttl_list, new_objects = \
                process_sentence_verb(narr_gender, sentence_text, sentence_offset, verb, subjects,
                                      last_date, last_loc, new_loc, last_nouns, processed_locs,
                                      False)   # Not xcomp processing
            add_unique_to_array(new_objects, objects)       # Track all object nouns
            sentence_ttl_list.extend(new_ttl_list)
        graph_ttl_list.extend(sentence_ttl_list)
        # Update last_nouns to all the subjects/objects of the sentence
        add_unique_to_array(objects, subjects)   # Add objects -> subjects
        last_nouns = copy.deepcopy(subjects)     # Reset last_nouns to the nouns from the current sentence
        # Update the last_loc
        if new_loc:
            last_loc = new_loc
    # Finished with all the sentences
    return graph_ttl_list


# Functions internal to the module but accessible to testing
def create_ttl_for_prep_detail(processed_preps: list, event_uri: str, processed_locs: dict,
                               sentence_text: str) -> list:
    """
    Parse the details for a verb's prepositions and create the corresponding Turtle. Note that
    dates/times are not handled in this code, but for the sentence overall (in create_event_turtle).

    :param processed_preps: A list of tuples holding the preposition text, its object text
                            and object type
    :param event_uri: The URI for the verb/event
    :param processed_locs: A dictionary of location texts (keys) and their URI (values) of
                           all locations already processed
    :param sentence_text: The full text of the sentence (needed for checking for idioms)
    :return A list holding the Turtle statements describing the preposition semantics
    """
    ttl_list = []
    for prep in processed_preps:
        prep_text, obj_text, obj_type = prep
        obj_uri = f':{obj_text.replace(" ", "_")}'
        # PROPRIETARY: Replace with full code from private repository
        noun_ttl = [f'{obj_uri} a owl:Thing ; rdfs:label "{obj_text}" .']   # Placeholder for public repository
        noun_str = str(noun_ttl)
        # Relationships for an Agent are different than for other "things"
        if ':Person' in noun_str or 'Agent' in noun_str or ':Organization' in noun_str:
            if prep_text == 'from':
                ttl_list.append(f'{event_uri} :has_provider {obj_uri} .')
            elif prep_text == 'to':
                ttl_list.append(f'{event_uri} :has_recipient {obj_uri} .')
            elif prep_text == 'for':
                ttl_list.append(f'{event_uri} :has_affected_agent {obj_uri} .')
            elif prep_text == 'with':
                ttl_list.append(f'{event_uri} :has_active_agent {obj_uri} .')
        else:
            if prep_text == 'with':
                ttl_list.append(f'{event_uri} :has_instrument {obj_uri} .')
            elif prep_text in prep_to_predicate_for_locs.keys() and ':Location' in noun_str:
                ttl_list.append(f'{event_uri} {prep_to_predicate_for_locs[prep_text]} {obj_uri} .')
            elif prep_text in ('about', 'of', 'from', 'to'):
                ttl_list.append(f'{event_uri} :has_topic {obj_uri} .')
    return ttl_list


def get_preposition_details(prep_dict: dict) -> list:
    """
    Extracts the details from the preposition dictionary of a verb.

    :param prep_dict: A dictionary holding the details for a single preposition for a verb
                      For example, "{'prep_text': 'with', 'prep_details': [{'detail_text': 'other children',
                      'detail_type': 'PLURALNOUN'}]"
    :return An array holding tuples consisting of the preposition text, and the preposition's object
            text(s) and object type(s)
    """
    prep_details = []
    if 'prep_details' in prep_dict.keys():
        for prep in prep_dict['prep_details']:
            if 'detail_text' in prep.keys():
                prep_detail_type = prep['detail_type']
                if prep_detail_type.endswith('DATE') or prep_detail_type.endswith('TIME') or  \
                        prep_detail_type.endswith('EVENT'):
                    # Time-related - so, this is already handled => ignore
                    continue
                prep_details.append((prep_dict['prep_text'].lower(), prep['detail_text'], prep['detail_type']))
    return prep_details


def process_sentence_verb(narr_gender: str, sentence_text: str, sentence_offset: int,
                          verb_dict: dict, subjects: list, last_date: str, last_loc: str, new_loc: str,
                          last_nouns: list, processed_locs: dict, is_xcomp: bool) -> (str, list, list):
    """
    Generate the Turtle for the root event/verb of the sentence, based on the details for the verb
    in the sentence dictionary.

    :param narr_gender: Either an empty string or one of the values, AGENDER, BIGENDER, FEMALE or MALE -
                        indicating the gender of the narrator
    :param sentence_text: The full text of the sentence (needed for checking for idioms)
    :param sentence_offset: Integer indicating the order of the sentence in the overall narrative
    :param verb_dict: The verb details from the sentence dictionary
    :param subjects: A list of texts of the subjects of the sentence
    :param last_date: The inferred (or explicit) time of the event, formatted as:
                      ('before'|'after'|'') (PointInTime date)
    :param last_loc: An inferred location of the event, if not supplanted by new info from the sentence
                     - OR - the origin location for a movement/transport
    :param new_loc: A new location defined in the sentence, or an empty string (if no location is specified)
    :param last_nouns: A list of all noun text and type tuples that is used for co-reference resolution
                       (it is updated with new nouns from the verb prepositions)
    :param processed_locs: A dictionary of location texts (keys) and their URI (values) of
                           all locations already processed
    :param is_xcomp: Boolean indicating that the verb processing is part of xcomp processing (if true)
    :return A tuple with 1) a string that is the event URI, 2) a list of Turtle statements describing
            the event, and 3) an array of tuples of the verb's object nouns and their types
    """
    logging.info(f'Processing verb, {verb_dict["verb_lemma"]}')
    ttl_list = []
    objects = []
    event_uri = f':Event_{str(uuid.uuid4())[:13]}'
    ttl_list.append(f'{event_uri} :text "{sentence_text}" ; :sentence_offset {sentence_offset} .')
    if 'negation' in verb_dict.keys():
        ttl_list.append(f'{event_uri} :negation true .')
    verb_keys = verb_dict.keys()
    # PROPRIETARY: Replace with full code from private repository
    ttl_list.append(f'{event_uri} a :EventAndState .')
    ttl_list.append(f'{event_uri} :sentiment {get_sentence_sentiment(sentence_text)} .')
    return event_uri, ttl_list, objects
